include { VG_CONSTRUCT } from '../../modules/nf-core/vg/construct/main.nf'
include { VG_INDEX } from '../../modules/nf-core/vg/index/main'
include { VG_AUTOINDEX } from '../../modules/local/vg/autoindex/main.nf'
include { VG_GIRAFFE } from '../../modules/local/vg/giraffe/main.nf'
include { VG_FILTER } from '../../modules/local/vg/filter/main.nf'
include { VG_PACK } from '../../modules/local/vg/pack/main.nf'
include { VG_SNARLS } from '../../modules/local/vg/snarls/main.nf'
include { VG_CALL } from '../../modules/local/vg/call/main.nf'
include { BCFTOOLS_SORT } from '../../modules/nf-core/bcftools/sort/main'
include { BCFTOOLS_INDEX } from '../../modules/nf-core/bcftools/index/main'
include { BCFTOOLS_REHEADER } from '../../modules/nf-core/bcftools/reheader/main'
include { BCFTOOLS_CONCAT } from '../../modules/nf-core/bcftools/concat/main'
include { BCFTOOLS_MERGE } from '../../modules/nf-core/bcftools/merge/main'
include { BCFTOOLS_NORM } from '../../modules/nf-core/bcftools/norm/main'
include { VG_PATHS } from '../../modules/local/vg/paths/main'
include { TABIX_TABIX } from '../../modules/nf-core/tabix/tabix/main'
include { TABIX_TABIX as TABIX_TABIX_1} from '../../modules/nf-core/tabix/tabix/main'
include { TABIX_SUBSET } from '../../modules/local/tabix/tabix/main'
include { TABIX_TABIX as TABIX_TABIX_2} from '../../modules/nf-core/tabix/tabix/main'
include { SAMTOOLS_FAIDX } from '../../modules/nf-core/samtools/faidx/main'
include { VG_STATS } from '../../modules/local/vg/stats/main'
include { VG_SURJECT } from '../../modules/local/vg/surject/main'
include { FREEBAYES } from '../../modules/nf-core/freebayes/main'

workflow VG_TOOLKIT {


    // Reference Genome
    ch_fasta = Channel.fromPath ( file(params.fasta) ).map { genome -> 
                tuple ([id:genome.simpleName], genome) }

    // Switches for using params index or build one in nextflow
    if (params.tbi) {
    
        ch_vcf_tbi = Channel.fromPath ( file(params.vcf) ).map { vcf -> 
                tuple ([id:vcf.simpleName], vcf, file(params.tbi)) }
    
    } else {
        
        ch_vcf = Channel.fromPath( file(params.vcf) ).map { vcf -> 
                tuple ([id:vcf.simpleName], vcf) }
        
        ch_tbi = TABIX_TABIX_1(ch_vcf).out.tbi

        ch_vcf_tbi = ch_vcf.join(ch_tbi, by:0).map {it[0],it[1],it[2]}
    
    }
    if (params.fai) {
        
        ch_fai = Channel.fromPath ( file(params.fai) ).map { fai -> 
                tuple ([id:fai.simpleName], fai) }
    
    } else {

        ch_fai = SAMTOOLS_FAIDX ( ch_fasta, [[:],[]] ).out.fai

    }

    // -----------------------------------------------------------------
    // Create Channel with List of Chromosomes (Scaffolds/Contigs)
    // 
    ch_fai.map{it[1]}.splitCsv(sep:'\t').map{it[0]}.set{contig}

    // subset vcf to contain specific regions
    TABIX_SUBSET ( ch_vcf_tbi, contig )

    // Augment Channel to include meta.region
    ch_subset_vcf = TABIX_SUBSET.out.vcf.map { meta, vcf ->
            WorkflowVG.createMetaMap(meta, vcf)
        }

    TABIX_TABIX ( ch_subset_vcf )

    ch_vcf_tbi_insfasta = ch_subset_vcf.join( TABIX_TABIX.out.tbi ).map { meta, vcf, tbi -> [meta, vcf, tbi, []] }

    VG_CONSTRUCT ( ch_vcf_tbi_insfasta, ch_fasta, ch_fai, contig )

    VG_INDEX ( VG_CONSTRUCT.out.graph )

    ch_vcf_tbi_fasta_fai = ch_vcf_tbi_insfasta.map{meta, vcf, tbi, insfasta -> [meta, vcf, tbi]}
        .combine(ch_fasta.map{it[1]})
        .combine(ch_fai.map{it[1]})

    VG_AUTOINDEX ( ch_vcf_tbi_fasta_fai, 'giraffe' )

    ch_gbz_min_dist = VG_AUTOINDEX.out.gbz
        .join(VG_AUTOINDEX.out.min, by: 0)
        .join(VG_AUTOINDEX.out.dist, by: 0)
        .map{meta, gbz, min, dist -> [gbz, min, dist]}

    // now create fastq channel for alignment using giraffe
    ch_fq = Channel.fromFilePairs(params.fq).map { id, fq ->
                tuple ([id:fq[0].simpleName], fq)
                }.combine(ch_gbz_min_dist).view()
    
    VG_GIRAFFE ( ch_fq )

    VG_FILTER ( VG_GIRAFFE.out.gam, VG_INDEX.out.xg.first() )

    VG_STATS ( VG_FILTER.out.gam )

    VG_SNARLS ( VG_INDEX.out.xg )

    // pre-compute gt support
    VG_PACK ( VG_FILTER.out.gam, VG_AUTOINDEX.out.gbz.first() )

    // call indv. genotypes
    VG_CALL ( VG_PACK.out.pack, VG_AUTOINDEX.out.gbz.first(), VG_SNARLS.out.snarls.first() )
    
    if (params.enable_freebayes) {
        VG_SURJECT ( VG_GIRAFFE.out.gam )

        SAMTOOLS_MERGE ( all_bam_files )

        ch_freebayes = FREEBAYES ( merged_bam_bai_bed_fasta_fai ).out.vcf
    }

    BCFTOOLS_SORT ( VG_CALL.out.vcf )

    BCFTOOLS_REHEADER ( BCFTOOLS_SORT.out.vcf )

    BCFTOOLS_INDEX ( BCFTOOLS_REHEADER.out.vcf )

    // rewrite meta.id based on letters before number for grouping
    ch_vcf_tbi = BCFTOOLS_REHEADER.out.vcf
    .join( BCFTOOLS_INDEX.out.tbi )
    .map { meta, vcf, tbi ->
        def metaG = [:]
        metaG.id = meta.id.split(/[^\p{L}]/)[0]
        [[ id:metaG.id ], vcf, tbi ]
    }
    .groupTuple(by:0)

    BCFTOOLS_MERGE ( ch_vcf_tbi )

    TABIX_TABIX_2 ( BCFTOOLS_MERGE.out.merged_variants )

    if (params.normalize_variants) {
        VG_PATHS ( VG_CONSTRUCT.out.graph )

        ch_vcf_tbi = BCFTOOLS_MERGE.out.merged_variants.join(TABIX_TABIX_2.out.tbi, by:0)

        BCFTOOLS_NORM ( ch_vcf_tbi, VG_PATHS.out.fasta )
    }

    emit:
    norm_vcf = BCFTOOLS_NORM.out.vcf
}